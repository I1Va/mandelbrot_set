# Исследование оптимизаций построения множества Мандельброта

**Автор**: Абрютин Иван Дмитриевич
**Дата**: 02.04.2025
**Курс**: 1, ИВТСП

## 1. Цель работы
Исследование влияния векторных оптимизаций `(AVX, SSE)` и параметров компиляции `(-Og, -O2, -Ofast)` на производительность алгоритма построения множества Мандельброта. Сравнение эффективности различных подходов: вычисления точек в массивах различной длины, intrinsics и ручной развертки циклов.
## 2. Теоритическая часть

### 2.1 Множество Мандельброта
Множество определяется как набор комплексных чисел, для которых итеративная последовательность:
$$ P_{n+1} =  P_{n} + P_0 $$



В данном множестве существует некоторое подмножество точек $P_0$, длина радиус вектора которых сходится. Будем называть эти точки `Стабильными`. Точки, для которых длина радиус вектора не сходится будем называть `Нестабильными`. Известно, что все стабильные точки $P$ на любой итерации находятся в пределах `Стабильного радиуса` $R_{stable}$

Для каждой же `Нестабильной точки` $P_0$ существует такая итерация `k`, что $P_k$ выходит за пределы $R_{stable}$

### 2.2 Построение
Сопоставим каждому пикселю точку на комплексной плоскости по формуле
$$P_0 = offset_P + PixelCord * scale$$

Для каждой точки $P_0$ попытаемся определить её тип: `Стабильная` или `Нестабильная`. В силу ограниченности вычислительных ресурсов для каждой точки $P_0$ сделаем допущение: будем считать ее `Стабильной`, если $P_{M}$ вышла за пределы `Стабильного радиуса`, где $M$ - некоторая константа, отвечающая максимальному количеству итераций, отведенных на одну точку.

Итого, для каждой точки получим номер последней итерации $iters$, после которой ее тип был определен.

Покрасим пиксель, соответсвующий точке $P_0$ в цвет, составялющие которого считаются по формуле:

$$red = 0.1 + iters * 0.03 * 0.2$$
$$green = 0.2 + iters * 0.3 * 0.3$$
$$blue = 0.3 + iters * 0.3 * 0.1$$

Функцию, сопоставляющую каждой пиксельной координате ее цвет назовем `display`

### 2.3 Методы оптимизации
В данной работе целью оптимизации будет функция `display`.
Рассмотрим теоритический сведения, необходимые для ее оптимизации.

SIMD-инструкции (SSE, AVX): Параллельная обработка нескольких данных за такт с использованием 128-битных (xmm) и 256-битных (ymm) регистров.

Векторизация циклов: Автоматическое преобразование скалярных операций в векторные компилятором.

Развертка циклов (Loop Unrolling): увеличение производительности за счет уменьшения количества итераций и конвейеризации

Расматриваемые флаги оптимизации:

-Og

-O2

-Ofast




## 3. Ход работы

### 3.1 Описание реализаций функции `display`

Рассмотрим 3 варианта реализации функции `display`:
1) `Простая реализация` : за одну итерацию вычисляется цвет только одной точки

```c++
...
// while iters < MAX_ITERATIONS_CNT
    x2 = x * x;
    y2 = y * y;
    xy = x * y;
...
```

2) С "`Массивной реализацией длины n`" : на каждой итерации происходит вычисление `ARR_SZ` точек, хранящихся в массиве
```c++
...
// while iters < MAX_ITERATIONS_CNT
for (int i = 0; i < ARR_SZ; i++) {
    x2_arr[i] = x_arr[i] * x_arr[i];
    y2_arr[i] = y_arr[i] * y_arr[i];
    abs_arr[i] = x2_arr[i] + y2_arr[i];
}
...
```
3) `Intrinsic` реализация, которая точечными вставками преобразует вычисления над массивами из прошлой реализации в вычисления над упакованными мультимедийными векторами, используя наборы инструкций `AVX2`

```c++
...
// while iters < MAX_ITERATIONS_CNT
for (int i = 0; i < ARR_SZ; i++) {
    x2_vec8 = _mm256_mul_ps(x_vec8, x_vec8);
    y2_vec8 = _mm256_mul_ps(y_vec8, y_vec8);
    abs_vec8 = _mm256_add_ps(x2_vec8, y2_vec8);
}
...
```


4) `Intrinsic unroll n` - `Intrinsic` реализация, в которой развернут цикл по координате `x` в $n$ раз


### 3.2 Анализ трансляции функции `display` `массивной  реализации длины n`

Рассмотрим результаты компиляции с различными флагами
#### 3.2.0 Производительность

| Флаги                           | -Og       | -O2       | -Ofast    |
|---------------------------------|-----------|-----------|-----------|
| Массивная (n=4) (fps)           | 1.68      | 25.23     | 21.29     |
| Массивная (n=8) (fps)           | 2.45      | 41.88     | 12.07     |


#### 3.2.1 `n=4`, `-Og -msse4.2 -mavx2 -DNDEBUG`

- Видно, код транслируется без значительных оптимизаций. Массивы и циклы по 4 остались в ассемблерном коде. Производительность ~ `1.68 fps`
```c++
for (int i = 0; i < 4; i++) {
    x_arr4[i] = x2_arr4[i] - y2_arr4[i] + x0_arr4[i];
    y_arr4[i] = 2 * xy_arr4[i] + y0_arr4[i];
}
```

```nasm
.L12:
        movsx   rax, ecx
        vmovss  xmm0, DWORD PTR 64[rsp+rax*4]
        vsubss  xmm0, xmm0, DWORD PTR 80[rsp+rax*4]
        vaddss  xmm0, xmm0, DWORD PTR [rsp+rax*4]
        vmovss  DWORD PTR 32[rsp+rax*4], xmm0
        vmovss  xmm0, DWORD PTR 96[rsp+rax*4]
        vaddss  xmm0, xmm0, xmm0
        vaddss  xmm0, xmm0, DWORD PTR 16[rsp+rax*4]
        vmovss  DWORD PTR 48[rsp+rax*4], xmm0
        add     ecx, 1
```

#### 3.2.2 `n=4`, `-O2 -msse4.2 -mavx2 -DNDEBUG`
- При `-O2` компилятор свел работу с массивами и циклами по 4 к работе с мультимедийными регистрами xmm, что способствовало повешению производительности (до `25.23 fps`)
```c++
for (int i = 0; i < 4; i++) {
    x_arr4[i] = x2_arr4[i] - y2_arr4[i] + x0_arr4[i];
    y_arr4[i] = 2 * xy_arr4[i] + y0_arr4[i];
}
```
```nasm
vcmpltps        xmm3, xmm2, xmm4
vblendvps       xmm3, xmm4, xmm2, xmm3
vcmpltps        xmm2, xmm15, xmm4
vblendvps       xmm15, xmm4, xmm15, xmm2
```

#### 3.2.3 `n=4`, `-Ofast -msse4.2 -mavx2 -DNDEBUG`
- При `-Ofast` к моему удивлению производительность снизилась. Это связано с тем, что компилятор решил отказаться от мультимедийных регистров в пользу развертывания цикла и выполнения инструкций в приятной конвейеру независимой по данным последовательности инструкций. Производительность ~ `21.29 fps`


```c++
for (int i = 0; i < 4; i++) {
    x2_arr4[i] = x_arr4[i] * x_arr4[i];
    y2_arr4[i] = y_arr4[i] * y_arr4[i];
    abs_arr4[i] = x2_arr4[i] + y2_arr4[i];
}

for (int i = 0; i < 4; i++) {
    xy_arr4[i] = x_arr4[i] * y_arr4[i];
}

for (int i = 0; i < 4; i++) {
    x_arr4[i] = x2_arr4[i] - y2_arr4[i] + x0_arr4[i];
    y_arr4[i] = 2 * xy_arr4[i] + y0_arr4[i];
}
```
- Для упрощения читаемости примера, переименую переменные

```c++
for (int i = 0; i < 4; i++) {
    x2[i] = x[i] * x[i];
    y2[i] = y[i] * y[i];
    abs[i] = x2[i] + y2[i];
}

for (int i = 0; i < 4; i++) {
    xy[i] = x[i] * y[i];
}

for (int i = 0; i < 4; i++) {
    x[i] = x2[i] - y2[i] + x0[i];
    y[i] = 2 * xy[i] + y0[i];
}
```
- Наглядно видно, что инструкции 1-7, 8-14 можно исполнить параллельно
```nasm
1) vmulss  xmm5, xmm14, xmm14          ; x2[0] = x[0] * x[0]
2) xor     edi, edi
3) vmulss  xmm14, xmm0, xmm14          ; xy[0] = y[0] * x[0]
4) vmulss  xmm11, xmm13, xmm13         ; x2[1] = x[1] * x[1]
6) vmulss  xmm13, xmm13, xmm1          ; xy[1] = y[1] * x[1]
7) vmulss  xmm4, xmm0, xmm0            ; y2[0] = y[0] * y[0]

8) vmovss  DWORD PTR 12[rsp], xmm5     ; сохранение x2[0]
9) vmulss  xmm5, xmm1, xmm1            ; y2[1] = y[1] * y[1]
10) vmovss  xmm1, DWORD PTR 12[rsp]    ; xmm1 = x2[0]
11) vaddss  xmm14, xmm14, xmm14         ; y[0] = 2 * xy[0]
12) vmulss  xmm7, xmm9, xmm9            ; y2[2] = y[2] * y[2]
13) vmulss  xmm8, xmm12, xmm12          ; y2[3] = y[3] * y[3]
14) vaddss  xmm13, xmm13, xmm13         ; y[1] = 2 * xy[1]
и т.д.
```

#### 3.2.3 `n=8`, `-O2 -msse4.2 -mavx2 -DNDEBUG`
В предыдущих пунктах рассматривась `массивная реализации длины 4`. Проведя тесты для длины 4, 8, 16, 32, 64, 128 я выяснил, что наибольшее ускорение дает `массивная реализация длины 8` с флагом компиляции `-O2`. Проанализировав асемблерный код, я выяснил, что это значительное ускорение достигается засчет использования мультимедийных операций над регистрами ymm. Производительность ~ `41.88 fps`


```c++
 // ARR_SZ = 8
 for (int i = 0; i < ARR_SZ; i++) {
    x_arr[i] = x2_arr[i] - y2_arr[i] + x0_arr[i];
    y_arr[i] = 2 * xy_arr[i] + y0_arr[i];
}
```

```asm
    vsubps  ymm2, ymm2, ymm6
    vaddps  ymm1, ymm1, ymm1
```




### 3.2.1 Анализ трансляции функции `display` с `intrinsics`
Аналогично реализации с массивной оптимизации длины 8, реализация с intrinsics при компиляции с флагом `-O2` использует мультимедийные регистры AVX ymm. Но несмотря на данное сходство, производительность реализации с intrinsics составляет ~ `58.47 fps`. Это связано с тем, что реализация с intrinsics гарантированно раскрывается в мультимедийные операции, а также генерирует меньше асемблерных инструкций (проверил в godbolt).

### 3.2.2 Изучение реализации с intrinsics unroll 2
А что если совместить использование AVX регистров в intrinsic, развертку циклов и скомпилировать с флагом оптимизации `-O2`? Получится производительность (~ `94.69 fps`).

### 3.3.2 Итоговые результаты
## Результаты измерений производительности (FPS)

| Оптимизация                     | -Og                  | -O2                  | -Ofast               | Лучший результат      |
|---------------------------------|----------------------|----------------------|----------------------|-----------------------|
| Без оптимизаций                 | 7.85             | 8.53    | 8.18    | 8.53     |
| Массивная (n=4)                 | 1.68                 | **25.23**            | 21.29                | **25.23**             |
| Массивная (n=8)                 | 2.45          | **41.88**| 12.07            | **41.88** |
| Intrinsics (AVX)                | 54.50    | **58.57**| 51.84    | **58.57** |
| Intrinsics (VX) + Unroll 2x          | 87.53    | **97.90**| 97.24    | **97.90** |

### 4. Вывод
- Были рассмотрены различные реализации функций построения множества Мандельброта.

- Была продемонстрирована эффективность комбинирования вставочных мультимедийных операций AVX и разворачивания циклов.