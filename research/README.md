# Исследование оптимизаций построения множества Мандельброта

**Автор**: Абрютин Иван Дмитриевич
**Дата**: 02.04.2025
**Курс**: 1, ИВТСП


## Изучение реализации с массивной оптимизацией

Рассмотрим результаты компиляции с различными флагами

### `-Og -msse4.2 -mavx2 -DNDEBUG`

- Видно, код транслируется без значительных оптимизаций. Массивы и циклы по 4 остались в ассемблерном коде. Производительность ~ `6 fps`
```c++
for (int i = 0; i < 4; i++) {
    x_arr4[i] = x2_arr4[i] - y2_arr4[i] + x0_arr4[i];
    y_arr4[i] = 2 * xy_arr4[i] + y0_arr4[i];
}
```

```nasm
.L12:
        movsx   rax, ecx
        vmovss  xmm0, DWORD PTR 64[rsp+rax*4]
        vsubss  xmm0, xmm0, DWORD PTR 80[rsp+rax*4]
        vaddss  xmm0, xmm0, DWORD PTR [rsp+rax*4]
        vmovss  DWORD PTR 32[rsp+rax*4], xmm0
        vmovss  xmm0, DWORD PTR 96[rsp+rax*4]
        vaddss  xmm0, xmm0, xmm0
        vaddss  xmm0, xmm0, DWORD PTR 16[rsp+rax*4]
        vmovss  DWORD PTR 48[rsp+rax*4], xmm0
        add     ecx, 1
```

### `-O2 -msse4.2 -mavx2 -DNDEBUG`
- При `-O2` компилятор свел работу с массивами и циклами по 4 к работе с мультимедийными регистрами xmm, что способствовало ускорению в ~4 раза (до `24 fps`)
```c++
for (int i = 0; i < 4; i++) {
    x_arr4[i] = x2_arr4[i] - y2_arr4[i] + x0_arr4[i];
    y_arr4[i] = 2 * xy_arr4[i] + y0_arr4[i];
}
```
```nasm
vcmpltps        xmm3, xmm2, xmm4
vblendvps       xmm3, xmm4, xmm2, xmm3
vcmpltps        xmm2, xmm15, xmm4
vblendvps       xmm15, xmm4, xmm15, xmm2
```

### `-Ofast -msse4.2 -mavx2 -DNDEBUG`
- При `-Ofast` к моему удивлению производительность снизилась. Это связано с тем, что компилятор решил отказаться от мультимедийных регистров в пользу развертывания цикла и выполнения инструкций в приятной конвейеру независимой по данным последовательности инструкций. Производительность ~ `20 fps`


```c++
for (int i = 0; i < 4; i++) {
    x2_arr4[i] = x_arr4[i] * x_arr4[i];
    y2_arr4[i] = y_arr4[i] * y_arr4[i];
    abs_arr4[i] = x2_arr4[i] + y2_arr4[i];
}

for (int i = 0; i < 4; i++) {
    xy_arr4[i] = x_arr4[i] * y_arr4[i];
}

for (int i = 0; i < 4; i++) {
    x_arr4[i] = x2_arr4[i] - y2_arr4[i] + x0_arr4[i];
    y_arr4[i] = 2 * xy_arr4[i] + y0_arr4[i];
}
```
- Для упрощения читаемости примера, переименую переменные

```c++
for (int i = 0; i < 4; i++) {
    x2[i] = x[i] * x[i];
    y2[i] = y[i] * y[i];
    abs[i] = x2[i] + y2[i];
}

for (int i = 0; i < 4; i++) {
    xy[i] = x[i] * y[i];
}

for (int i = 0; i < 4; i++) {
    x[i] = x2[i] - y2[i] + x0[i];
    y[i] = 2 * xy[i] + y0[i];
}
```
- Наглядно видно, что инструкции 1-7, 8-14 можно исполнить параллельно
```nasm
1) vmulss  xmm5, xmm14, xmm14          ; x2[0] = x[0] * x[0]
2) xor     edi, edi
3) vmulss  xmm14, xmm0, xmm14          ; xy[0] = y[0] * x[0]
4) vmulss  xmm11, xmm13, xmm13         ; x2[1] = x[1] * x[1]
6) vmulss  xmm13, xmm13, xmm1          ; xy[1] = y[1] * x[1]
7) vmulss  xmm4, xmm0, xmm0            ; y2[0] = y[0] * y[0]

8) vmovss  DWORD PTR 12[rsp], xmm5     ; сохранение x2[0]
9) vmulss  xmm5, xmm1, xmm1            ; y2[1] = y[1] * y[1]
10) vmovss  xmm1, DWORD PTR 12[rsp]    ; xmm1 = x2[0]
11) vaddss  xmm14, xmm14, xmm14         ; y[0] = 2 * xy[0]
12) vmulss  xmm7, xmm9, xmm9            ; y2[2] = y[2] * y[2]
13) vmulss  xmm8, xmm12, xmm12          ; y2[3] = y[3] * y[3]
14) vaddss  xmm13, xmm13, xmm13         ; y[1] = 2 * xy[1]
и т.д.
```

## Замечание
В предыдущих пунктах рассматривась массивная оптимизации длины 4. Проведя тесты для длины 4, 8, 16, 32, 64, 128 я выяснил, что наибольшее ускорение дает массивная оптимизация длины 8 с флагом компиляции `-O2`. Проанализировав асемблерный код, я выяснил, что это значительное ускорение достигается засчет использования мультимедийных операций над регистрами ymm. Производительность ~ `40 fps`


```c++
 // ARR_SZ = 8
 for (int i = 0; i < ARR_SZ; i++) {
    x_arr[i] = x2_arr[i] - y2_arr[i] + x0_arr[i];
    y_arr[i] = 2 * xy_arr[i] + y0_arr[i];
}
```

```asm
    vsubps  ymm2, ymm2, ymm6
    vaddps  ymm1, ymm1, ymm1
```




## Изучение реализации с intrinsics
Аналогично реализации с массивной оптимизации длины 8, реализация с intrinsics при компиляции с флагом `-O2` использует мультимедийные регистры AVX ymm. Но несмотря на данное сходство, производительность реализации с intrinsics составляет ~ `52 fps`. Это связано с тем, что реализация с intrinsics гарантированно раскрывается в мультимедийные операции, а также генерирует меньше асемблерных инструкций (проверил в godbolt).

## Изучение реализации с intrinsics unroll 2
А что если совместить использование AVX регистров в intrinsic, развертку циклов и скомпилировать с флагом оптимизации `-O2`? Получится производительность x1.7 (~ `90 fps`)! А все благодаря конвейеризации.

## Изучение реализации с intrinsics unroll 4
А что если совместить использование AVX регистров в intrinsic, развертку циклов и скомпилировать с флагом оптимизации `-O2`? Получится производительность x2 (~ `100 fps`)! А все благодаря конвейеризации.


## Вывод
В данной работе была продемонстрирована эффективность мультимедийных операций AVX2 и использование компилятором такой оптимизации, как разворачивание циклов.